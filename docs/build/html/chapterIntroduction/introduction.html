

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Overview &mdash; VERSEM alpha documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Spectral Element Method Formulation" href="../chapterTheory/theory.html" />
    <link rel="prev" title="VERSEM" href="../versemDoc.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../versemDoc.html" class="icon icon-home"> VERSEM
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#motivation">Motivation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#prior-work">Prior Work</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-solver">The Solver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-weak-form-of-the-elastic-wave-equation">The Weak Form of the Elastic Wave Equation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-shape-functions">The Shape Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-matrix-assembly">Global Matrix Assembly</a></li>
<li class="toctree-l3"><a class="reference internal" href="#time-marching">Time Marching</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parallelisation">Parallelisation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#organization">Organization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#input">Input</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parameter-file">Parameter File</a></li>
<li class="toctree-l4"><a class="reference internal" href="#source-file">Source File</a></li>
<li class="toctree-l4"><a class="reference internal" href="#station-file">Station File</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mesh-file">Mesh File</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pre-processing">Pre-Processing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#model-object"><code class="docutils literal notranslate"><span class="pre">Model_object</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#output">Output</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#seismograms">Seismograms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wavefield-snapshots">Wavefield Snapshots</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#post-processing">Post-Processing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unit-testing">Unit Testing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#schedule-and-division-of-labor">Schedule And Division of Labor</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#schedule">Schedule</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dec-2018-prototype">11 Dec, 2018: Prototype</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dec-2018-finish-the-main-solver">31 Dec, 2018: Finish the main solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#jan-2019-final-version">9 Jan, 2019: Final version</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#division-of-labor">Division of Labor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#building-the-automatic-documentation-with-sphinx">Building the Automatic Documentation with Sphinx</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapterTheory/theory.html">Spectral Element Method Formulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../chapterModules/modules.html">Modules</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../versemDoc.html">VERSEM</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../versemDoc.html">Docs</a> &raquo;</li>
        
      <li>Overview</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/chapterIntroduction/introduction.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="overview">
<h1>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h1>
<div class="section" id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="Permalink to this headline">¶</a></h2>
<p>Over the last 20 years, the seismology division of the Geoscience
Department at Princeton University has been developing a software suite
to solve the elastic wave equation using the Spectral Element method
<a class="reference internal" href="../versemDoc.html#komatitsch1999" id="id1">[KT99]</a>. Since the spectral element method
cannot only be used to solve the wave equation, but partial differential
equations in general, the group has started to develop solvers for other
equations as well, e.g. Maxwell’s equation for magnetic anomalies. Since
the original code was setup to only compute the elastic wave equation,
it is structured to be 100% efficient and not modular. Its organisation
is too hard to grasp, making it hard to learn, understand and especially
modify. We want to overcome this issue by using the ideas of the old
code base and create a new version of the code that is structured well
and easy to modify in terms of adding a PDE solver. We will tackle this
problem by first using the example of the wave equation because we have
a benchmark of a working code. However, it will be taken into account
that the code is supposed to not only solve for the wave equation but
also other PDE’s.</p>
</div>
<div class="section" id="prior-work">
<h2>Prior Work<a class="headerlink" href="#prior-work" title="Permalink to this headline">¶</a></h2>
<p>The work that has been done until now (referring to the existing code)
is all written in Fortran90. Since our goal is to make the code human
readable as modular, we will write the code from scratch. That does not
mean that we will forget the existing code, but that we will use it a
reference for a new version.</p>
</div>
<div class="section" id="the-solver">
<h2>The Solver<a class="headerlink" href="#the-solver" title="Permalink to this headline">¶</a></h2>
<p>The numerical solution of the wave equation using the Spectral Element
Method (SEM), much like the Finite Element Method (FEM), is based on the
weak form of the equation. For a discrete set of elements and
corresponding nodes, PDEs can be solved using a linear system.</p>
<div class="section" id="the-weak-form-of-the-elastic-wave-equation">
<h3>The Weak Form of the Elastic Wave Equation<a class="headerlink" href="#the-weak-form-of-the-elastic-wave-equation" title="Permalink to this headline">¶</a></h3>
<p>is based on the weak solution of the elastic wave equation.</p>
<div class="math notranslate nohighlight">
\[\rho\: \partial^2_t\mathbf{u} = \nabla \cdot \left( \mathbf{c}\, \colon\!  \nabla \mathbf{u} \right) + \mathbf{f},\]</div>
<p>where (from left to right) <span class="math notranslate nohighlight">\(\rho\)</span> is the density,
<span class="math notranslate nohighlight">\(\partial_t\)</span> is the differential operator with respect to time,
<span class="math notranslate nohighlight">\(\mathbf{u}\)</span> is the displacement, <span class="math notranslate nohighlight">\(\nabla\)</span> is the gradient
operator in space, <span class="math notranslate nohighlight">\(\mathbf{c}\)</span> is the elastic tensor (Hooke’s
law: <span class="math notranslate nohighlight">\(\mathbf{T} = \mathbf{c}\, \colon\!  \nabla \mathbf{u} `) and
:math:\)</span>mathbf{f}` is an external force acting on the system. The weak
form of the elastic wave equation can then be formed by the multiplying
the elastic wave equation with a test function <span class="math notranslate nohighlight">\(\hat{\phi}\)</span> and
integrating it over the domain <span class="math notranslate nohighlight">\(\Omega\)</span>:</p>
<div class="math notranslate nohighlight">
\[\int_{\Omega} \hat{\phi} \: \rho\: \partial^2_t \mathbf{u} \: dV = \int_{\Omega} \hat{\phi} \: \nabla \cdot \left( \mathbf{c}\, \colon\!  \nabla \mathbf{u} \right) \: dV + \int_{\Omega} \hat{\phi} \: \mathbf{f} \: dV\]</div>
<p>By using Green’s theorem, we can simplify the double spatial gradient:</p>
<div class="math notranslate nohighlight">
\[\int_{\Omega} \hat{\phi} \: \rho\: \partial^2_t \mathbf{u} \: dV =  \oint_{\partial\Omega} \hat{\phi} \:\mathbf{T} \cdot \mathbf{\hat{n}} \: dS - \int_{\Omega} \nabla \hat{\phi} \cdot \left( \mathbf{c}\, \colon\!  \nabla \mathbf{u} \right) \: dV + \int_{\Omega} \hat{\phi} \: \mathbf{f} \: dV\]</div>
<p>Now, if our domain can be split into elements <span class="math notranslate nohighlight">\(\mathbf{e}\)</span> which
are formed by discrete data points we can interpolate the interior of
each element the using shape functions. Particularly, within such
elements, we can assume that the displacement <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> can be
expressed in form of a sum discrete points multiplied by connecting
shape functions, such that:</p>
<div class="math notranslate nohighlight">
\[\label{eq:discrete_disp}
    u^i(\mathbf{x},t) =  \phi _ { 1 } ( \mathbf { x } ) u _ { 1 }^i(t) + \phi _ { 2 } ( \mathbf { x } ) u _ { 2 }^i(t) + \cdots = \sum _ { l = 1 } ^ { N n } \phi_{l}(\mathbf{x})u_{l}^i(t),\]</div>
<p>where <span class="math notranslate nohighlight">\(Nn\)</span> is the number of nodes per element and <span class="math notranslate nohighlight">\(i\)</span>
denotes the component of the displacement vector.</p>
<div class="math notranslate nohighlight">
\[\sum_{l=1}^{Nn} \int_{\Omega} \hat{\phi} \: \rho\: \partial^2_t \phi_{l}(\mathbf{x})u_{l}^i(t) \: dV  + \int_{\Omega} \nabla \hat{\phi} \cdot \left( \mathbf{c}\, \colon\!  \nabla \phi_{l}(\mathbf{x})u_{l}^i(t) \right) \: dV = \oint_{\partial\Omega} \hat{\phi} \:\mathbf{T} \cdot \mathbf{\hat{n}} \: dS  + \int_{\Omega} \hat{\phi} \: \mathbf{f} \: dV\]</div>
<p>If we choose <span class="math notranslate nohighlight">\(\hat{\phi}(\mathbf{x})\)</span> to be</p>
<p><span class="math notranslate nohighlight">\(\phi_{k}(\mathbf{x})\)</span> for every <span class="math notranslate nohighlight">\(k\)</span> from 1 to <span class="math notranslate nohighlight">\(Nn\)</span>,</p>
<p>we can further reduce the problem to</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
     \sum_{l=1}^{Nn} &amp; \int_{\Omega} \phi_{k} \: \rho\: \partial^2_t \phi_{l}\: u_{l}^i(t) \: dV  \nonumber\\
       &amp;+ \int_{\Omega} \nabla \phi_{k} \cdot \left( \mathbf{c}\, \colon\!  \nabla \phi_{l} \: u_{l}^i(t) \right) \: dV
       \nonumber\\
       &amp;\quad -  \int_{\Omega} \phi_{k} \: \mathbf{f}  \: dV = \oint_{\partial\Omega} \phi_{k} \:\mathbf{T} \cdot \mathbf{\hat{n}} \: dS    \end{aligned}\end{split}\]</div>
<p>As given by the above equation the factors <span class="math notranslate nohighlight">\(u^i_l\)</span> are completely
independent of the integration over the domain <span class="math notranslate nohighlight">\(\Omega\)</span>. Hence, we
can write</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
     \sum_{l=1}^{Nn} &amp; \int_{\Omega} \rho\: \phi_{k} \:  \phi_{l} \: dV \: \partial^2_tu_{l}^i(t) \nonumber\\
       &amp;+ \int_{\Omega} \nabla \phi_{k} \cdot \left( \mathbf{c}\, \colon\!  \nabla \phi_{l} \right) \: dV \: u_{l}^i(t)
       \nonumber\\
       &amp;\quad - \int_{\Omega} \phi_{k} \: \mathbf{f}   \: dV = \oint_{\partial\Omega} \phi_{k} \:\mathbf{T} \cdot \mathbf{\hat{n}} \: dS  \end{aligned}\end{split}\]</div>
</div>
<div class="section" id="the-shape-functions">
<h3>The Shape Functions<a class="headerlink" href="#the-shape-functions" title="Permalink to this headline">¶</a></h3>
<p>For each element, we can convert the global coordinates
<span class="math notranslate nohighlight">\(\mathbf{x}\)</span> to local coordinates that range from
<span class="math notranslate nohighlight">\(( \xi , \eta ) , \quad - 1 \leq \xi \leq 1,- 1 \leq \eta \leq 1\)</span>.
The conversion from local to global coordinates is governed by the
transformation using so called shape functions such that</p>
<div class="math notranslate nohighlight">
\[\mathbf { x } ( \xi , \eta ) = \sum _ { a = 1 } ^ { n _ { a } } N _ { a } ( \xi , \eta ) \mathbf { x } _ { a }.\]</div>
<p>The SEM’s signature shape functions are the Lagrange Polynomials
<span class="math notranslate nohighlight">\(l^{n_l}_\alpha\)</span>:</p>
<div class="math notranslate nohighlight">
\[\ell _ { \alpha } ^ { n _ { \ell } } ( \xi ) = \frac { \left( \xi - \xi _ { 0 } \right) \cdots \left( \xi - \xi _ { \alpha - 1 } \right) \left( \xi - \xi _ { \alpha + 1 } \right) \cdots \left( \xi - \xi _ { n _ { \ell } } \right) } { \left( \xi _ { \alpha } - \xi _ { 0 } \right) \cdots \left( \xi _ { \alpha } - \xi _ { \alpha - 1 } \right) \left( \xi _ { \alpha } - \xi _ { \alpha + 1 } \right) \cdots \left( \xi _ { \alpha } - \xi _ { n _ { \ell } } \right) }\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha = 0,...,n_l\)</span>, and <span class="math notranslate nohighlight">\(n_l\)</span> will be 5 to 10 (in
our case).</p>
<ul class="simple">
<li>using shape functions and the transformation with Jacobian to get
from global to local integration</li>
<li>Gauss-Lobatto-Legendre Quadrature to approximate the integrals</li>
<li></li>
</ul>
</div>
<div class="section" id="global-matrix-assembly">
<h3>Global Matrix Assembly<a class="headerlink" href="#global-matrix-assembly" title="Permalink to this headline">¶</a></h3>
<p>Since all elements are interconnected and dependent on each other, they
need to be assembled in a linear system of equations.</p>
<ul class="simple">
<li>diagonal Mass matrix, simplifies things…</li>
<li>this, that</li>
</ul>
<p>Then, we end up with following system of equations:</p>
<div class="math notranslate nohighlight">
\[\mathbf{M} \ddot { \mathbf{u} } + \mathbf{K} \mathbf{u} = \mathbf{f}\]</div>
<p>However, <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> is still dependent on time. To solve this a
simple finite difference scheme can be applied or other time marching
methods.</p>
</div>
<div class="section" id="time-marching">
<h3>Time Marching<a class="headerlink" href="#time-marching" title="Permalink to this headline">¶</a></h3>
<p>The linear system of equations can then be solved using a simple finite
difference scheme, where</p>
<div class="math notranslate nohighlight">
\[\mathbf { u } ( t + d t ) = d t ^ { 2 } \left( \mathbf { M } ^ { T } \right) ^ { - 1 } \left[ \mathbf { f } - \mathbf { K } ^ { T } \mathbf { u } \right] + 2 \mathbf { u } - \mathbf { u } ( t - d t ).\]</div>
<p>While we will focus on this scheme first of all, we want to allow for
other time schemes as well, e.g. Crank-Nicholson, to allow for more
robust time marching using other PDEs.</p>
</div>
<div class="section" id="parallelisation">
<h3>Parallelisation<a class="headerlink" href="#parallelisation" title="Permalink to this headline">¶</a></h3>
<p>There are two types of parallelisation that can possibly be done. The
first one is the embarassingly parallel job of integration at element
level. This should be relatively simple implement. However, the
integration at element level is not the bottleneck of the computation,
the bottleneck is the solving of the linear system when marching in
time. The second type of parallelisation, which is often used in such
cases, is domain decomposition and synchronisation. Meaning the domain
is split into subdomains which overlap and are synchronised after each
time-step.</p>
</div>
</div>
<div class="section" id="organization">
<h2>Organization<a class="headerlink" href="#organization" title="Permalink to this headline">¶</a></h2>
<p>Due to our decision to make this code as easy to understand and modular
as possible, we decided to write the code in Python. We will however
keep the option open to write certain ’under the hood functions’ in C or
C++, so that there is a possibility of a quick speed up.</p>
<div class="section" id="input">
<h3>Input<a class="headerlink" href="#input" title="Permalink to this headline">¶</a></h3>
<p>The input parameter files will be in YAML format. They include
information of physics and simulation of this problem. For physics, it
contains the following information, solver type, mesh type, equation
type, Gauss - Lobatto - Legendre Points (GLL points), post-processing
software and possibly more. The mesh will be created externally.</p>
<div class="section" id="parameter-file">
<h4>Parameter File<a class="headerlink" href="#parameter-file" title="Permalink to this headline">¶</a></h4>
<p>A YAML parameter file will be given to provide necessary settings.
Parameters will be stored as a dictionary in a configuration object,
which will include methods like get(), set(), has(), etc. Paremeters
include:</p>
<ol class="arabic simple">
<li>Compute SH or P-SV wave</li>
<li>Boundary conditions</li>
<li>Interval of output snapshots</li>
<li>Number of timesteps</li>
<li>Length of one timestep</li>
</ol>
</div>
<div class="section" id="source-file">
<h4>Source File<a class="headerlink" href="#source-file" title="Permalink to this headline">¶</a></h4>
<p>The source file is a YAML file which contains the following information:</p>
<ol class="arabic simple">
<li>Location</li>
<li>Frequency</li>
<li>Source time function (either built-in SFT or points to an external
STF file)</li>
<li>Starting time</li>
<li>Angle</li>
<li>Moment tensor</li>
<li>Amplification factor</li>
</ol>
</div>
<div class="section" id="station-file">
<h4>Station File<a class="headerlink" href="#station-file" title="Permalink to this headline">¶</a></h4>
<p>The station file is a YAML file which contains the location information.</p>
</div>
<div class="section" id="mesh-file">
<h4>Mesh File<a class="headerlink" href="#mesh-file" title="Permalink to this headline">¶</a></h4>
<p>The mesh file will be created by an external meshing software. In this
project, we will use Cubit. Cubit outputs an Exodus file (<code class="docutils literal notranslate"><span class="pre">.e</span></code>) which
will be used to create a model object</p>
</div>
</div>
<div class="section" id="pre-processing">
<h3>Pre-Processing<a class="headerlink" href="#pre-processing" title="Permalink to this headline">¶</a></h3>
<p>The GLL points contain the total number of points and the weight at each
point to approximate the integral with the weighted sum. We will use a
library of hard-coded GLL points and weights for the Quadrature
calculating them.</p>
<p>For each node, the Jacobian has to be calculated and saved since the
locations of the nodes are not changing. This is necessary to convert
the coordinates from the global coordinate system to the local
(elemental) coordinate system on each for the local GLL quadrature (as
described in section [sec:gmatassembly]).</p>
</div>
<div class="section" id="model-object">
<h3><code class="docutils literal notranslate"><span class="pre">Model_object</span></code><a class="headerlink" href="#model-object" title="Permalink to this headline">¶</a></h3>
<p>From input parameters that described the model as well as the input mesh
file are converted into a <code class="docutils literal notranslate"><span class="pre">model_object</span></code>. A complete model consists of
an Exodus (<code class="docutils literal notranslate"><span class="pre">.e</span></code>) file, which is produced using an external mesher and
a file that describes the material. The Exodus file will be read as a
<span class="math notranslate nohighlight">\(2\times N\)</span> array, (<span class="math notranslate nohighlight">\(N\)</span> is the number of points, which
contains the location of each point. The material file is a
<span class="math notranslate nohighlight">\(3\times N\)</span> binary array (3 parameters are P-wave velocity, S-wave
velocity and density). A model object that contains the arrays will be
created. The <code class="docutils literal notranslate"><span class="pre">model_object</span></code> contains methods to iterate through points
and get neighbouring points ().</p>
</div>
<div class="section" id="output">
<h3>Output<a class="headerlink" href="#output" title="Permalink to this headline">¶</a></h3>
<div class="section" id="seismograms">
<h4>Seismograms<a class="headerlink" href="#seismograms" title="Permalink to this headline">¶</a></h4>
<p>Seismograms records the velocity or displacement as a function of time.
For each station, a binary array of velocity or displacement will be
stored. The input station file will be copied to the output directory so
that the output directory contains the complete seismogram information.</p>
</div>
<div class="section" id="wavefield-snapshots">
<h4>Wavefield Snapshots<a class="headerlink" href="#wavefield-snapshots" title="Permalink to this headline">¶</a></h4>
<p>Snapshots of the wavefield (either velocity or displacement) can be
configured as an output. The snapshots will be stored as a
<span class="math notranslate nohighlight">\(1\times N\)</span> binary arrays. The Exodus file of the model will be
copied to the output directory, as well, so that the output contains all
necessary information.</p>
</div>
</div>
<div class="section" id="post-processing">
<h3>Post-Processing<a class="headerlink" href="#post-processing" title="Permalink to this headline">¶</a></h3>
<p>The post-processing software could be Paraview, Matlab or Matplotlib in
Python, which will be the default. The post-processing may not be of
priority in this project.</p>
</div>
<div class="section" id="unit-testing">
<h3>Unit Testing<a class="headerlink" href="#unit-testing" title="Permalink to this headline">¶</a></h3>
<p>The unit test of this project will be implemented with Jenkins. Everyone
will submit his own tests to the server independently, which means all
the group members will do the unit test in the sections he is
responsible for.</p>
</div>
</div>
<div class="section" id="schedule-and-division-of-labor">
<h2>Schedule And Division of Labor<a class="headerlink" href="#schedule-and-division-of-labor" title="Permalink to this headline">¶</a></h2>
<div class="section" id="schedule">
<h3>Schedule<a class="headerlink" href="#schedule" title="Permalink to this headline">¶</a></h3>
<div class="section" id="dec-2018-prototype">
<h4>11 Dec, 2018: Prototype<a class="headerlink" href="#dec-2018-prototype" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="dec-2018-finish-the-main-solver">
<h4>31 Dec, 2018: Finish the main solver<a class="headerlink" href="#dec-2018-finish-the-main-solver" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="jan-2019-final-version">
<h4>9 Jan, 2019: Final version<a class="headerlink" href="#jan-2019-final-version" title="Permalink to this headline">¶</a></h4>
</div>
</div>
<div class="section" id="division-of-labor">
<h3>Division of Labor<a class="headerlink" href="#division-of-labor" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><strong>Congyue Cui:</strong> Coding of the input and output design</div>
<div class="line"><strong>Chao Song:</strong> Coding of the visualisation and details</div>
<div class="line"><strong>Fan Wu:</strong> Coding of the main solver</div>
<div class="line"><strong>Lucas Sawade:</strong> Coding of the main solver</div>
<div class="line"><strong>Srijan Bharati Das:</strong> Coding of the main solver</div>
<div class="line"><strong>ALL:</strong> Skeleton design; unit test; Documentation</div>
</div>
</div>
<div class="section" id="building-the-automatic-documentation-with-sphinx">
<h3>Building the Automatic Documentation with Sphinx<a class="headerlink" href="#building-the-automatic-documentation-with-sphinx" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../chapterTheory/theory.html" class="btn btn-neutral float-right" title="Spectral Element Method Formulation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../versemDoc.html" class="btn btn-neutral" title="VERSEM" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Congyue Cui, Srijan Bharati Das, Lucas Sawade, Chao Song, Fan Wu

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'alpha',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>