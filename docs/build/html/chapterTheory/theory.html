

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Spectral Element Method Formulation &mdash; VERSEM alpha documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Modules" href="../chapterModules/modules.html" />
    <link rel="prev" title="Overview" href="../chapterIntroduction/introduction.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../versemDoc.html" class="icon icon-home"> VERSEM
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../chapterIntroduction/introduction.html">Overview</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Spectral Element Method Formulation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#seismic-wave-equation-fem-solver">Seismic Wave Equation: FEM Solver</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#weak-form-and-element-matrices">Weak form and element matrices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#finding-the-total-number-of-nodes-to-be-computed">Finding the total number of nodes to be computed:</a></li>
<li class="toctree-l3"><a class="reference internal" href="#element-and-node-numbering">Element and Node Numbering</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lagrange-polynomials">Lagrange Polynomials</a></li>
<li class="toctree-l3"><a class="reference internal" href="#derivative-of-the-lagrange-polynomials">Derivative of the Lagrange Polynomials</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-jacobian">The Jacobian</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#time-stepping">Time Stepping</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../chapterModules/modules.html">Modules</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../versemDoc.html">VERSEM</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../versemDoc.html">Docs</a> &raquo;</li>
        
      <li>Spectral Element Method Formulation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/chapterTheory/theory.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="spectral-element-method-formulation">
<h1>Spectral Element Method Formulation<a class="headerlink" href="#spectral-element-method-formulation" title="Permalink to this headline">¶</a></h1>
<p>This chapter is for documenting the theoretical aspect of the solver and
associated routines. One can refer to the equations and the
corresponding code to be clear about the implementations.</p>
<div class="section" id="seismic-wave-equation-fem-solver">
<h2>Seismic Wave Equation: FEM Solver<a class="headerlink" href="#seismic-wave-equation-fem-solver" title="Permalink to this headline">¶</a></h2>
<div class="section" id="weak-form-and-element-matrices">
<h3>Weak form and element matrices<a class="headerlink" href="#weak-form-and-element-matrices" title="Permalink to this headline">¶</a></h3>
<p>We are solving the seismic wave equation in 2D:</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\rho \ddot{u}_{\rm{i}} = \partial_{\rm{j}} \tau_{\rm{ij}} + f_{\rm{i}}
\end{aligned}\]</div>
<p>The above equation is in component form where the subscript i denotes
the component of <span class="math notranslate nohighlight">\(\vec{u}\)</span>. <span class="math notranslate nohighlight">\(\tau_{\rm{ij}}\)</span> is the second
order stress tensor and <span class="math notranslate nohighlight">\(\vec{f}\)</span> denotes the external force
distribution. <span class="math notranslate nohighlight">\(\tau_{\rm{ij}}\)</span> is expressed as:</p>
<div class="math notranslate nohighlight">
\[\tau_{\rm{ij}} = \lambda \delta_{\rm{ij}} e_{\rm{kk}} + 2 \mu e_{\rm{ij}}\]</div>
<p>and,</p>
<div class="math notranslate nohighlight">
\[e_{\rm{ij}} = \frac{1}{2}(\partial_{\rm{i}}u_{\rm{j}} + \partial_{\rm{j}}u_{\rm{i}})\]</div>
<p>Therefore, the wave equation reads as:</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\rho \ddot{u}_{\rm{i}} = \partial_{\rm{j}}\bigg(\frac{\lambda \delta_{\rm{ij}}}{2}(\partial_{\rm{k}}u_{\rm{k}} + \partial_{\rm{k}}u_{\rm{k}})\bigg) + \partial_{\rm{j}}\bigg(\mu (\partial_{\rm{i}}u_{\rm{j}} + \partial_{\rm{j}}u_{\rm{i}}) \bigg) + f_{\rm{i}}\end{aligned}\]</div>
<p>For starting off, we consider constant <span class="math notranslate nohighlight">\(\lambda\)</span> and <span class="math notranslate nohighlight">\(\mu\)</span>.
So, we assume homogeneous and isotropic medium properties.</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\rho \ddot{u}_{\rm{i}} = \lambda \partial_{\rm{i}}(\partial_{\rm{k}} u_{\rm{k}}) + \mu(\partial_{\rm{i}}(\partial_{\rm{j}}u_{\rm{j}}) + \partial_{\rm{j}}^2 u_{\rm{i}})\end{aligned}\]</div>
<p>Hereafter, we switch to the weak formulation and multiply
<span class="math notranslate nohighlight">\(N_{\rm{l}}\)</span>, the <span class="math notranslate nohighlight">\(l\)</span>-th shape function throughout the
equation and integrate over the area element <span class="math notranslate nohighlight">\(dxdy\)</span>. We expand the
displacement <span class="math notranslate nohighlight">\(\vec{u}\)</span> in terms of the components
<span class="math notranslate nohighlight">\(u_{\rm{i}}(x,y) = \sum_{m=1}^{nip} u_{\rm{i}}^{\rm{m}}(x,y) N_{\rm{m}}(x,y)\)</span>,
where <span class="math notranslate nohighlight">\(nip\)</span> is the total number of GLL points per element where
integration has to be carried out. Therefore, the term on the left hand
side becomes:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
&amp;=&amp; \int N_l(x,y) \rho(x,y) \ddot{u}_{\rm{i}}(x,y)dxdy \\
&amp;=&amp; \int_{-1}^{1} N_l(\xi,\eta) \rho(\xi,\eta) \sum_{m=1}^{nip} \ddot{u}_{\rm{i}}^{\rm{m}} N_{\rm{m}}(\xi,\eta) \mathcal{J}(\xi,\eta) d\xi d\eta \\
&amp;=&amp; \sum_{k=1}^{nip} N_l(\xi_{\rm{k}},\eta_{\rm{k}}) \rho(\xi_{\rm{k}},\eta_{\rm{k}}) \sum_{m=1}^{nip} \ddot{u}_{\rm{i}}^{\rm{m}} N_{\rm{m}}(\xi_{\rm{k}},\eta_{\rm{k}}) \mathcal{J}(\xi_{\rm{k}},\eta_{\rm{k}}) W_{\rm{k}},\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(W_{\rm{k}} = w_{\rm{k1}} w_{\rm{k2}}\)</span>, the product of the
weights of the constitutive lagrange polynomials at those GLL points.
<span class="math notranslate nohighlight">\(\mathcal{J}\)</span> is the determinant of the Jacobian for transforming
the integral variables from global to local coordinates. So, we sum over
all the GLL points in an element with adequate weights to perform the 2D
integral. However, the shape functions
<span class="math notranslate nohighlight">\(N_{\rm{m}}(\xi_{\rm{k}},\eta_{\rm{k}}) = \delta_{\rm{mk}}\)</span> and
hence the remaining summation can be expressed as a product of a
diagonal mass matrix and a column vector <span class="math notranslate nohighlight">\(u_{\rm{i}}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\sum_{k=1}^{nip} \rho(\xi_{\rm{k}},\eta_{\rm{k}}) \mathcal{J}(\xi_{\rm{k}},\eta_{\rm{k}}) W_{\rm{k}} \ddot{u}_{\rm{i}}^{\rm{k}}\]</div>
<p>Hence we are finally left with the local mass matrix:
<span class="math notranslate nohighlight">\(\rho(\xi_{\rm{k}},\eta_{\rm{k}}) \mathcal{J}(\xi_{\rm{k}},\eta_{\rm{k}}) W_{\rm{k}}\)</span>,
where <span class="math notranslate nohighlight">\(k\)</span> is the GLL point number for an element. These will form
the diagonal elements of out matrix for each element.</p>
<p>The vectorial representation of the second term in 3D looks like the
following:</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\int_V N_l \nabla \cdot \mathbf{\tau} dV\end{aligned}\]</div>
<p>Using Gauss’ theorem and assuming a stress free boundary condition such
that <span class="math notranslate nohighlight">\(\mathbf{\tau}\cdot \mathbf{\hat{\mathbf{n}}} = 0,\)</span> where
<span class="math notranslate nohighlight">\(\mathbf{\hat{\mathbf{n}}}\)</span> is the normal to the boundary surface.
So, we are left with:</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\int_V N_l \nabla \cdot \mathbf{\tau} dV = -\int_V \nabla N_l \cdot \mathbf{\tau}dV\end{aligned}\]</div>
<p>In case of 2D, writing in a component form yields the equations:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
&amp;=&amp; -\int \partial_j N_l \tau_{ij} dxdy \\
&amp;=&amp; -\int \partial_j N_l(x,y) \lambda(x,y) \delta_{ij} \partial_r u_r dxdy \nonumber \\ &amp;-&amp; \int \partial_j N_l(x,y) \mu(x,y)(\partial_i u_j + \partial_j u_i)dxdy\end{aligned}\end{split}\]</div>
<p>Let the first term be A:</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
&amp;=&amp; -\int \partial_j N_l(x,y) \lambda(x,y) \delta_{ij} \partial_r \sum_m N_m(x,y) u_r^m dxdy\end{aligned}\]</div>
<p>While the second term can be split into B and C respectively:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
&amp;-&amp; \int \partial_j N_l(x,y) \mu(x,y) \partial_i \sum_m N_m(x,y) u_j^m \nonumber \\ &amp;-&amp;  \int \partial_j N_l \mu(x,y) \partial_j \sum_m N_m(x,y) u_j^m dxdy\end{aligned}\end{split}\]</div>
<p>Now, we can convert the global coordinates (x,y) to local coordinate
(<span class="math notranslate nohighlight">\(\xi,\eta\)</span>) using the Jacobian <span class="math notranslate nohighlight">\(\mathcal{J(\xi,\eta)}\)</span> and
use the quadrature to further simplifiy the integral into:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
A &amp;=&amp; -\int_{-1}^{1} \partial_i N_l(\xi,\eta) \lambda(\xi,\eta) \sum_m (\partial_r N_m(\xi,\eta))u_r^m \mathcal{J}^{-1}(\xi,\eta) d\eta d\xi \\
&amp;=&amp; -\sum_{k=1}^{nip} \partial_i N_l(\xi_k,\eta_k) \lambda(\xi_k,\eta_k) \sum_m (\partial_r N_m(\xi_k,\eta_k))u_r^m \mathcal{J}^{-1}(\xi_k,\eta_k) W_k \nonumber \\ \\
&amp;=&amp; -\sum_{m=1}^{nip} u_{\mathbf{r}}^m \sum_{k=1}^{nip} \partial_i N_l(\xi_k,\eta_k) \lambda(\xi_k,\eta_k) \partial_{\mathbf{r}} N_m(\xi_k,\eta_k) \mathcal{J}^{-1}(\xi_k,\eta_k) W_k \nonumber \\\end{aligned}\end{split}\]</div>
<p>The bold subscript is to remind ourselves that the index needs to be
summed over for all the components (<span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> in 2D and
<span class="math notranslate nohighlight">\(x,y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> in 3D). Similarly,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
B &amp;=&amp; - \int_{-1}^{1} \partial_j N_l(\xi,\eta) \mu(\xi,\eta) \sum_m \partial_i N_m(\xi,\eta) u_j^m \mathcal{J}^{-1}(\xi,\eta) d\xi d\eta \\
&amp;=&amp; -\sum_{k=1}^{nip} \partial_j N_l(\xi_k,\eta_k) \mu(\xi_k,\eta_k) \sum_m \partial_i N_m(\xi_k,\eta_k) u_j^m \mathcal{J}^{-1}(\xi_k,\eta_k) W_k \nonumber \\ \\
&amp;=&amp; -\sum_{m=1}^{nip} u_{\mathbf{j}}^m \sum_{k=1}^{nip} \partial_{\mathbf{j}} N_l(\xi_k,\eta_k) \mu(\xi_k,\eta_k) \partial_i N_m(\xi_k,\eta_k) \mathcal{J}^{-1}(\xi_k,\eta_k) W_k \nonumber \\\end{aligned}\end{split}\]</div>
<p>Finally,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
C &amp;=&amp; -\int_{-1}^{1} \partial_j N_l(\xi,\eta) \mu(\xi,\eta) \sum_m \partial_j N_m(\xi,\eta) u_i^m \mathcal{J}^{-1}(\xi,\eta) d\xi d\eta \\
&amp;=&amp; -\sum_{k=1}^{nip} \partial_j N_l(\xi_k,\eta_k) \mu(\xi_k,\eta_k) \sum_m \partial_j N_m(\xi_k,\eta_k) u_i^m \mathcal{J}^{-1}(\xi_k,\eta_k) W_k \nonumber\\ \\
&amp;=&amp; -\sum_{m=1}^{nip} u_i^m \sum_{k=1}^{nip} \partial_{\mathbf{j}} N_l(\xi_k,\eta_k) \mu(\xi_k,\eta_k) \partial_{\mathbf{j}} N_m(\xi_k,\eta_k) \mathcal{J}^{-1}(\xi_k,\eta_k) W_k \nonumber\\ \end{aligned}\end{split}\]</div>
<p>If we notice, the expression of A,B and C have free indices as
<span class="math notranslate nohighlight">\(l\)</span> and <span class="math notranslate nohighlight">\(i\)</span>. Here, <span class="math notranslate nohighlight">\(i\)</span> denotes the component of
<span class="math notranslate nohighlight">\(\vec{u}\)</span> that we are solving for and <span class="math notranslate nohighlight">\(l\)</span> denotes the row
number of the column vector <span class="math notranslate nohighlight">\(u_i\)</span>.</p>
</div>
<div class="section" id="finding-the-total-number-of-nodes-to-be-computed">
<h3>Finding the total number of nodes to be computed:<a class="headerlink" href="#finding-the-total-number-of-nodes-to-be-computed" title="Permalink to this headline">¶</a></h3>
<p>The following formula is to find the total number of computational nodes
(including the GLL points) for a rectangular mesh which have to be
solved for at each time step:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
N_{total} &amp;=&amp; ((n_y \times N_y) - (N_y - 1)) \times (N_x + 1) \nonumber \\ &amp;+&amp; ((n_x - 2) \times N_x) \times (N_y + 1) \nonumber \\ + ((n_x &amp;\times&amp; n_y - 2 (n_y + n_x) + 4))\times (N_x \times N_y)\end{aligned}\end{split}\]</div>
<p>where, <span class="math notranslate nohighlight">\(n_i\)</span> is the number of nodes per element in the along i-th
coordinate and <span class="math notranslate nohighlight">\(N_i\)</span> is the number of elements along the i-th
coordinate. Therefore, if we have a mesh with <span class="math notranslate nohighlight">\(n_x\)</span> = <span class="math notranslate nohighlight">\(n_y\)</span>
= 5 and <span class="math notranslate nohighlight">\(N_x\)</span> = 20 and <span class="math notranslate nohighlight">\(N_y\)</span> = 10, then <span class="math notranslate nohighlight">\(N_{total}\)</span> =
3321.</p>
</div>
<div class="section" id="element-and-node-numbering">
<h3>Element and Node Numbering<a class="headerlink" href="#element-and-node-numbering" title="Permalink to this headline">¶</a></h3>
<p>The method developed here relies on a FEM mesh created by an external
meshing software, which creates a <code class="docutils literal notranslate"><span class="pre">.e</span></code> Exodus file. The Exodus file
provides all the necessary information for a mesh: (a) the coordinates
of the nodes defining the control points, (b) connectivity of the
elements, as well as (c) the boundary nodes. This information is used to
create an arbitrary number of interpolation points on each element with
a new set of connectivity and numbers. This ensures that increasing
computational power can be harnessed for higher accuracy. The input mesh
therefore contains only quadrilaterals defined by four nodes (as of now;
will be extended to higher number of nodes in the future). The functions
used to read and redefine the mesh are located within the
<code class="docutils literal notranslate"><span class="pre">src/mesh_spec.py</span></code> script. The numbering itself is performed using the
following algorithm shown in figure [fig:element_numbering].</p>
<div class="figure" id="id2">
<img alt="Control points of initial mesh vs GLL collocation points" src="../_images/element_fig_edit.pdf" />
<p class="caption"><span class="caption-text">Example of GLL node and element numbering algorithm using 5x5 GLL
points and two elements. The numbers in the red, rounded boxes denote
the element number. The circles and white boxed numbers show the
control point locations and numbers, respectively. the small crosses
and numbers show the GLL point locations and numbers, respectively.</span></p>
</div>
<p>In the figure, we show the GLL points in each direction, and also the
GLL points lie on the edges as well as the interior of each element. The
locations of the GLL points contribute to the simplification of the mass
matrix, which becomes diagonal, because of the GLL quadrature used.</p>
</div>
<div class="section" id="lagrange-polynomials">
<h3>Lagrange Polynomials<a class="headerlink" href="#lagrange-polynomials" title="Permalink to this headline">¶</a></h3>
<p>The chosen test functions for the spectral element method are the
Lagrange polynomials. The Lagrange polynomials are interpolation
polynomials between certain points and defined in the following manner.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\label{eq:lagrange}
    \ell^n_i(\xi) = \prod_{\substack{j = 0\\ j \neq i}}^{n+1} \frac{\xi - \xi_j}{\xi_i - \xi_j},\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\xi_i\)</span> are the collocation points, <span class="math notranslate nohighlight">\(i\)</span> is the number
of the polynomial with respect to collocation points and <span class="math notranslate nohighlight">\(n\)</span> is
the degree of the polynomial <a class="reference internal" href="../versemDoc.html#komatitsch1999" id="id1">[KT99]</a>. The
implemented algorithm follows this formulation strictly. In multiple
dimensions, the shapefunctions <span class="math notranslate nohighlight">\(N\)</span>, are defined as the product of
the polynomials in each dimension., i.e.
<span class="math notranslate nohighlight">\(N_{kl}(\xi,\eta) = \ell^n_k(\xi)\ell^n_l(\eta).\)</span></p>
</div>
<div class="section" id="derivative-of-the-lagrange-polynomials">
<h3>Derivative of the Lagrange Polynomials<a class="headerlink" href="#derivative-of-the-lagrange-polynomials" title="Permalink to this headline">¶</a></h3>
<p>As seen in the section [sec:theory], the spectral element method also
requires the derivative of the shape functions. The derivative of the
Lagrange polynomials are defined as the original Lagrange polynomial
multiplied by the Legendre polynomial. The Legendre polynomial
<span class="math notranslate nohighlight">\(P^n_i\)</span> is given by following sum</p>
<div class="math notranslate nohighlight">
\[\begin{split}P^n_i(\xi) = \sum_{\substack{j = 0\\ j \neq i}}^{n+1} \frac{1}{\xi - \xi_j},\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\xi_i\)</span> are the collocation points, <span class="math notranslate nohighlight">\(i\)</span> is the
polynomial number with respect to the collocation point and <span class="math notranslate nohighlight">\(n\)</span> is
the polynomial degree. Hence, the derivative of the Lagrange polynomial
(Eq. [eq:lagrange]) is given as</p>
<div class="math notranslate nohighlight">
\[\frac{d\ell^n_i}{d\xi} = P^n_i(\xi)\ell^n_i(\xi).\]</div>
<p>The equation becomes more elaborate when writing out all the component:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{d\ell^n_i}{d\xi} =  \sum_{\substack{k = 0\\ k \neq i}}^{n+1} \left( \frac{1}{\xi - \xi_k} \prod_{\substack{j = 0\\ j \neq i}}^{n+1} \frac{\xi - \xi_j}{\xi_i - \xi_j} \right)\end{split}\]</div>
<p>This cannot be implemented as strictly as the Lagrange polynomial itself
since it would include a division by <span class="math notranslate nohighlight">\(0\)</span> at <span class="math notranslate nohighlight">\(\xi = \xi_k\)</span>.
However, a quick look at the denominator in the first term and the
numerator on the second term shows, that we have a cancellation when
<span class="math notranslate nohighlight">\((\xi - \xi_k) =  (\xi - \xi_j)\)</span>, or shorter, when <span class="math notranslate nohighlight">\(k=j\)</span>,
such that</p>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{d\ell^n_i}{d\xi} =  \sum_{\substack{k = 0\\ k \neq i}}^{n+1} \left[ \prod_{\substack{j = 0\\ j \neq i}}^{n+1} \left\{ \begin{array}{ll}
        \frac{1}{\xi_i - \xi_j},  &amp; \text{if } k=j \\
        \frac{\xi - \xi_j}{\xi_i - \xi_j}, &amp; \text{otherwise}
    \end{array} \right. \right].\end{split}\]</div>
<p>This is strictly followed in the algorithm.</p>
</div>
<div class="section" id="the-jacobian">
<h3>The Jacobian<a class="headerlink" href="#the-jacobian" title="Permalink to this headline">¶</a></h3>
<p>The Jacobian between local and global coordinates can be defined as</p>
<div class="math notranslate nohighlight">
\[\frac { \partial \mathbf { x } } { \partial \xi } = \sum _ { a = 1 } ^ { n _ { a } } \frac { \partial N _ { a } } { \partial \xi } \mathbf { x } _ { a }\]</div>
</div>
</div>
<div class="section" id="time-stepping">
<h2>Time Stepping<a class="headerlink" href="#time-stepping" title="Permalink to this headline">¶</a></h2>
<p>After reduction, we get the following ordinary differential equations we
are going to solve</p>
<div class="math notranslate nohighlight">
\[M\ddot{ U } +KU=F(t)\]</div>
<p>where M is the global mass matrix and it is time invarient, the K is the
global stiff matrix and it is also time invarient. In our case, the mass
matrix M is diagonal.</p>
<p>Generally, there are two approaches. One way is to transform the second
order equations into first order equations by <span class="math notranslate nohighlight">\(P=\dot { U }\)</span>,
then we need to solve the following equations</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix} I &amp; O \\ O &amp; M \end{pmatrix}\left( \begin{array}{c} \dot { U }  \\ \dot { P }  \end{array} \right) +\begin{pmatrix} O &amp; -I \\ K &amp; O \end{pmatrix}\left( \begin{array}{c} U \\ P \end{array} \right) =\left( \begin{array}{c} O \\ F \end{array} \right)\end{split}\]</div>
<p>using. The new global matrix is still diagonal. So we can use some
explicit time schemes like explicit Euler, fourth order Runge-Kutta to
solve the equations.</p>
<p>The other way is to solve the second order equations directly. There are
schemes like Newmark-<span class="math notranslate nohighlight">\(\beta\)</span> and HHT-<span class="math notranslate nohighlight">\(\alpha\)</span>. In order
to fully exploit the advantage of diagonal matrix, we only use a special
case of Newmark-<span class="math notranslate nohighlight">\(\beta\)</span> scheme, where <span class="math notranslate nohighlight">\(\beta=0\)</span>. The
algorithm is as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="7%" />
<col width="93%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" colspan="2"><strong>Algorithm 1</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1:</td>
<td><strong>Procedure</strong> <span class="math notranslate nohighlight">\(\text{NEWMARK}(U_n,V_n,A_n,dt,F)\)</span></td>
</tr>
<tr class="row-odd"><td>2:</td>
<td><span class="math notranslate nohighlight">\(U_{n+1}=U_n+V_ndt+0.5A_ndt^2\)</span></td>
</tr>
<tr class="row-even"><td>3:</td>
<td><span class="math notranslate nohighlight">\(A_{n+1}=M^{-1}F_{n+1}-M^{-1}KU_{n+1}\)</span></td>
</tr>
<tr class="row-odd"><td>4:</td>
<td><span class="math notranslate nohighlight">\(V_{n+1}=(1-\gamma)A_{n}dt+\gamma A_{n+1}dt\)</span></td>
</tr>
<tr class="row-even"><td>5:</td>
<td><strong>return</strong> <span class="math notranslate nohighlight">\(U_{n+1},V_{n+1},A_{n+1}\)</span></td>
</tr>
</tbody>
</table>
<p>where <span class="math notranslate nohighlight">\(V=\dot { U } ,A=\ddot { U }\)</span>. Typically, since the
dimensions of the matrix in Newmark scheme is smaller, the computation
is faster than indirect schemes. This is one reason why Newmark scheme
is popular in waveform modelling in seismology. So in our simulations,
we will mainly use Newmark scheme.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../chapterModules/modules.html" class="btn btn-neutral float-right" title="Modules" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../chapterIntroduction/introduction.html" class="btn btn-neutral" title="Overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, Congyue Cui, Srijan Bharati Das, Lucas Sawade, Chao Song, Fan Wu

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'alpha',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>